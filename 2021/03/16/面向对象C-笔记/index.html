<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Helloat123">





<title>面向对象C++笔记 | Richard&#39;s Blog</title>



    <link rel="icon" href="/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Richard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Richard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">面向对象C++笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Helloat123</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 16, 2021&nbsp;&nbsp;14:15:13</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <ul>
<li><p>写sort的时候可以用lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(vi.begin(),vi.end(),[](<span class="keyword">const</span> <span class="keyword">int</span> elem1, <span class="keyword">const</span> <span class="keyword">int</span> elem2)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> elem1&lt;elem2;&#125;); </span><br></pre></td></tr></table></figure>
</li>
<li><p>stl中的set有set_intersection，set_union，set_difference的功能，使用方法如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_difference(a.begin(),a.end(),b.begin(),b.end(),inserter(c,c.begin()));</span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_copy是unique相似用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_copy(ss.begin(),ss.end(),back_inserter(s));</span><br></pre></td></tr></table></figure>
</li>
<li><p>extern int i代表要到别的文件中找i</p>
</li>
<li><pre><code class="c++">vector&lt;int&gt;::const_iterator it1;//这玩意是不能改指向的数据
const vector&lt;int&gt;::iterator it2;//这玩意是自己不能改，没啥用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* const的含义是不能修改，可能是不能被修改的变量；constexpr的含义是真正的常量(比如固定的数字)，可以直接在编译期处理出来</span><br><span class="line"></span><br><span class="line">* 加::可以在局部调用全局变量，即使局部有同名变量</span><br><span class="line"></span><br><span class="line">* const int *p或者int const *p表示p指向的位置是个常量，但p不是；int *const p即可。若需要两者皆为常量，则int const *const p</span><br><span class="line"></span><br><span class="line">* nullptr代表空指针，但c中是NULL或0</span><br><span class="line"></span><br><span class="line">* 文件输入输出流fstream包含ifstream和ofstream，定义时</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;c++</span><br><span class="line">  ifstream fin&#123;&quot;a.txt&quot;&#125;;&#x2F;&#x2F;或者下面这样</span><br><span class="line">  ifstream fin;fin.open(&quot;a.txt&quot;);&#x2F;&#x2F;注意程序结束前要close</span><br><span class="line">  fin.close();</span><br></pre></td></tr></table></figure>

然后fin就可以当作一般的cin差不多用法了。

同时，这里定义的fin和cin都属于istream，其它也属于istream的还有stringstream，用法如下

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">strin</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">strin&gt;&gt;n;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>cin&gt;&gt;当中右移符号的返回值为左端的istream&amp;对象，因此在cin&gt;&gt;x&gt;&gt;y中，cin&gt;&gt;x执行完返回一个cin，继续读cin&gt;&gt;y。判断语句中cin会被强转为bool型。当cin.eof()为true的时候条件判断中的cin是false</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n) &#123;<span class="comment">/*what you want to do here*/</span>&#125;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>,s)) &#123;<span class="comment">/*...*/</span>&#125;<span class="comment">//返回值实际上也是个istream&amp;，和上面这句的返回值类型相同</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">cin</span>.eof()) &#123;<span class="built_in">cin</span>&gt;&gt;n;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>//这里不加点东西就会渲染失败</p>
</li>
<li><pre><code class="c++">void f(char);
void g(char &amp;);
void h(const char&amp;);
char c=&#39;A&#39;;int d=97;
f(&#39;a&#39;);//right
f(49);//right
f(c);//right
f(d);//right
g(&#39;a&#39;);//wrong you can&#39;t refer a constant
g(49);//wrong
g(c);//right
g(d);//wrong you can&#39;t refer a different variable type
h(&#39;a&#39;);//right  the compiler would introduce a temporary variable
h(49);//right the compiler would introduce a temporary variable
h(c);//right
h(d);//right the compiler would introduce a temporary variable
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里不加点东西就会渲染失败</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;c++</span><br><span class="line">  namespace My</span><br><span class="line">  &#123;</span><br><span class="line">      int a;</span><br><span class="line">      void f()&#123;a++&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  namespace AA</span><br><span class="line">  &#123;</span><br><span class="line">      using namespace My;&#x2F;&#x2F;直接把两个杂糅起来</span><br><span class="line">  &#125;</span><br><span class="line">  namespace AA</span><br><span class="line">  &#123;</span><br><span class="line">      int b;&#x2F;&#x2F;这样算作添加</span><br><span class="line">  &#125;</span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">      using namespace My;&#x2F;&#x2F;1 introduce all，更接近于全局和局部的关系 </span><br><span class="line">      using My::f;&#x2F;&#x2F;2 introduce My::f</span><br><span class="line">      using My::a;&#x2F;&#x2F;3 introduce My::a，只引入了一个局部标识符，和下面a同级</span><br><span class="line">      int a;&#x2F;&#x2F;4 与上面这行会矛盾，但与1不矛盾</span><br><span class="line">      cout&lt;&lt;a&lt;&lt;My::a&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>for static global names, use unnamed namespace to avoid their use in other source files.</p>
<p>如果是全局变量，就会在所有文件内生效，就乱套啦</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span><span class="comment">//effective in the whole source file </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ADL技术，又称koenig查找，会根据参数所在的命名空间找调用的函数</p>
</li>
<li><pre><code class="c++">namespace s=std;//重命名
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ODR技术 单一命名规则：不在同一个翻译空间内的两个一模一样的东西(名称和内部变量名等一切会被编译的东西)，会被认为是同一个东西，不会报错。（但是它有啥用？)</span><br><span class="line"></span><br><span class="line">* C++默认会把函数名改成包含参数和返回值信息的样子，来内部区分</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;c++</span><br><span class="line">  int &amp;use_count()&#x2F;&#x2F;alternative to use global variables</span><br><span class="line">  &#123;</span><br><span class="line">      static int uc&#x3D;initval;</span><br><span class="line">      return uc</span><br><span class="line">  &#125;</span><br><span class="line">  void f()&#123;use_count()++;&#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>try catch throw</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">throw</span> div0(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">throw</span> div0(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0x3f3f3f3f</span>) <span class="keyword">throw</span> aaa;<span class="comment">//if no catch matches it, the program will terminate</span></span><br><span class="line">    <span class="keyword">return</span> a/b+b/a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>,m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        f(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(div0 x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;div0&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//catch(...) to catch all other types</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>默认的class赋值是bitwise，但是如果里面有指针可能会出锅（从其中一个把它delete之后另一边就gg）</p>
</li>
<li><pre><code class="c++">class A&#123;
    int d;
    public:
        int getd() const;
        int getd(); //构成重载，会自动适配
    //重载就是同一个变量名不同函数
&#125;
int A::getd() const&#123;return d;&#125;
int A::getd()&#123;return d++;&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里不加点东西就会渲染失败</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;c++</span><br><span class="line">  class A</span><br><span class="line">  &#123;</span><br><span class="line">  private:</span><br><span class="line">     	int x,y;</span><br><span class="line">  public:</span><br><span class="line">      A&amp; operator+(const &amp;A);&#x2F;&#x2F;A后面的&amp;表示返回一个引用，可以修改。否则返回的是const的局部变量</span><br><span class="line">      &#x2F;&#x2F;返回值记得设return *this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
//这里不加点东西就会渲染失败</code></pre>
</li>
<li><pre><code class="c++">class A
&#123;
    void operator==(const &amp;A)=delete//禁止使用默认的==运算符
    void operator&amp;(const &amp;A)=delete//禁止使用默认的取地址运算符
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里不加点东西就会渲染失败</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;c++</span><br><span class="line">  class complex</span><br><span class="line">  &#123;</span><br><span class="line">  public:</span><br><span class="line">      complex&amp; operator+(const int &amp;b);</span><br><span class="line">  &#125;;</span><br><span class="line">  complex a;</span><br><span class="line">  int main()&#123;2+a&#x2F;&#x2F;wrong 只定义了a+2,没定义2+a</span><br><span class="line">  &#x2F;&#x2F;但是可以在class里面写个complex(const int &amp;b) &#123;x&#x3D;b;&#125;然后它就会自动转类型了</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>由于ADL，namespace当中会自动寻找操作数相同的重定义运算符来用。重载前后操作数相同，不能变化结合性</p>
</li>
<li><p>operator.和operator-&gt;的左边的东西不会被隐式转换</p>
</li>
<li><p>字面量操作符literal，可以实现1+2.0i这样的表示，方法就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span>_i(<span class="keyword">long</span> <span class="keyword">double</span> x)&#123;<span class="keyword">return</span> &#123;<span class="number">0</span>,x&#125;;&#125;<span class="comment">//必须放在class外</span></span><br></pre></td></tr></table></figure>

<p>其中long double是因为double不合法…这些是合法类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>*</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">wchar_t</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">char16_t</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">char32_t</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span></span><br></pre></td></tr></table></figure>

<p>老师ppt给的例子的字面量操作符没有下划线，但是貌似用户自定义的建议以下划线开头，因为以后的c++版本可能会用到不带下划线的。只会报warning</p>
</li>
<li><p>假设需要把当前class转化为已有类型T，那么在class里面写operator T(const T &amp;x)const{return xxxx;}</p>
</li>
<li><p>在某些式子里可能调用转换函数或者构造函数进行类型转换 为了避免ambiguity 使用显示转换</p>
</li>
<li><p>隐式转换最多帮你转一级，因为更多就会产生歧义</p>
</li>
<li><p>隐式转换时候必须保证唯一性，比如有个f(x)一个f(y),同时x和y都可以由int构造成，那么f(1)就gg</p>
</li>
<li><ol>
<li><p>Exact match</p>
</li>
<li><p>Match using promotions</p>
</li>
<li><p>Match using standard conversions</p>
</li>
<li><p>Match using user-defined conversions</p>
</li>
<li><p>Mismatch, function undeclared</p>
</li>
</ol>
</li>
<li><p>friend的声明位置无所谓private public</p>
</li>
<li><p>一个class的friend可以是另一个class的member function/一个class可以是另一个class的friend class</p>
</li>
<li><p>friend只是标明了这玩意存在，而没有真正定义它</p>
</li>
<li><p>friend class可以是前面定义过的class，也可以是后面定义、但在当前enclosing scope中定义的class</p>
</li>
<li><p>friend function可以是类似friend class的地方定义的，也可以是参数所在enclosing scope中定义的</p>
</li>
<li><p>关于右值引用和拷贝构造 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d19fc8447eaa">看这里</a></p>
</li>
<li><p>构造函数前加explicit就可以让这个构造函数只能被显式调用</p>
</li>
<li><p>为了区分是a++还是++a，定义的时候后缀多一个标记用的参数int。a++相当于a.operator++(0)</p>
</li>
<li><p>vtbl (v table)虚函数表 vptr虚函数表指针</p>
</li>
<li><p>析构通常都是虚函数</p>
</li>
<li><p>virtual void f()=0; 有纯虚函数的就是抽象类</p>
</li>
<li><pre><code class="c++">class D:public A,private B,protected C&#123;
//多重继承时要避免两边有一样的东西 二义性
//继承来继承去可能会生成一个DAG
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* string\&lt;T\&gt;里面的返回值只要写string，到了外面就得string\&lt;T\&gt;</span><br><span class="line"></span><br><span class="line">* 模板的实例化 第一次用到它时候就会把这个类型代进去，过程叫Template instantiation，结果叫specialization。成员函数用到了才会实例化。定义某个指针时候没必要马上把它指向的类型实例化</span><br><span class="line"></span><br><span class="line">*  &#96;&#96;&#96;c++ </span><br><span class="line">  template&lt;typename T,int i,typename compare&#x3D;std::less&lt;T&gt;&gt;&#x2F;&#x2F;std::less&lt;T&gt;是默认参数，如果没有就编译错误 compare如果要传入的话 就是传入一个返回值为bool的函数</span><br><span class="line">  class A</span><br><span class="line">  &#123;</span><br><span class="line">      T a[i];</span><br><span class="line">      bool f(T x,T y)&#123;return compare(x,y);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;i需要是编译期能搞定的值</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>更特殊的模板会优先选择(我能推出你 你不能推出我) ambiguous会CE</p>
</li>
<li><p>完全特例化complete specialization </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="keyword">void</span>*&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>部分特例化partial specialization</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>T*&gt;:<span class="keyword">private</span> Vector&lt;<span class="keyword">void</span>*&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RAII: Resource Acquisition Is Initialization 已构造的对象最终会销毁，即它的析构函数最终会被调用。函数在正常结束或者throw退出时候都会把局部的东西清掉</p>
</li>
<li><pre><code class="c++">#include &lt;exception&gt;
//standard exception 标准库异常</code></pre>
</li>
</ul>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/C/"># C++</a>
                    
                        <a href="/tags/OOP/"># OOP</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/03/17/ICPC2020-%E5%8C%97%E4%BA%9A%E6%AC%A7%E5%8C%BA/">ICPC2020-NorthernEurasia-NERC</a>
            
            
            <a class="next" rel="next" href="/2021/03/13/CF-Round-707-Div-2/">CF Round 707 (Div.2)</a>
            
        </section>


    </article>
</div>



    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: 'Ov23liMSvcFdnlsFKxr8',
        clientSecret: '8676e8a4b9a5e31bd17ad6b742c0e759e2c73a66',
        repo: 'Helloat123.github.io',
        owner: 'Helloat123',
        admin: 'Helloat123',
        id: location.pathname,
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

        </div>
        <footer id="footer" class="footer">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="copyright">
        <span>© Helloat123 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span> | <span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span></span>
    </div>
</footer>

    </div>
</body>
</html>
