<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Helloat123">





<title>算法分析自学手册 | Richard&#39;s Blog</title>



    <link rel="icon" href="/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 5.4.2"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Richard&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Richard&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">算法分析自学手册</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Helloat123</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 28, 2025&nbsp;&nbsp;20:12:30</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>接下来的题目中用到的默认读者已经掌握的知识：深度优先搜索、二分查找、一些基础的STL函数</p>
<p>如果不知道的话在用到的时候可以自己想办法学一下</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>DP，Dynamic Programming，指的是解决问题的一类思路。下面的思考过程直接看是很难看懂的，建议在阅读后面解题思路时回过头来套这样一种思考模式。</p>
<h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><ol>
<li>将原问题分解为子问题<br> 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。如果子问题都解决了，原问题就解决了<br> 子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。</li>
<li>确定状态<br> 在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。</li>
<li>确定一些初始状态（边界状态）的值</li>
<li>确定状态转移方程<br> 定义出什么是“状态”，以及在该 “状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的“状态”，求出另一个“状态”的“值” 。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。</li>
</ol>
<p>具体应用例子可以看“数字三角形”一题</p>
<h3 id="能用DP解决的问题的特点"><a href="#能用DP解决的问题的特点" class="headerlink" title="能用DP解决的问题的特点"></a>能用DP解决的问题的特点</h3><ol>
<li>问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。</li>
<li>无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</li>
</ol>
<h2 id="Naive"><a href="#Naive" class="headerlink" title="Naive"></a>Naive</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先从朴素想法入手：搜索。以每个最下面一排的位置为起点，向上搜索所有路径。这样的做法的时间复杂度是$O(n\cdot 2^n)$，难以通过本题。或者以最上面的位置为起点，向下搜索所有路径，搜索量是差不多的，思路也差不多，正确性也都可以保证。下面我们以自下而上的情况为例思考。</p>
<p>考虑搜索过程中是否有重复计算的内容。可以发现，对于两条自下而上搜索到一半的路径，如果它们当前的终点是相同的，那么接下来的决策将会相同。也就是说，我们其实可以将“从某个位置出发到最上面的最大路径和”看作一个子问题，显然对于每一个位置都存在这样的子问题，而每个子问题的答案可以只算一遍，算完将其保存下来以备之后查询。因此时间复杂度优化到了$O(n^2)$。这种方法被称为<strong>记忆化搜索</strong>。（《算法导论》中称为top-down with memoization）</p>
<h5 id="参考代码（记忆化搜索）"><a href="#参考代码（记忆化搜索）" class="headerlink" title="参考代码（记忆化搜索）"></a>参考代码（记忆化搜索）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,ans,a[<span class="number">111</span>][<span class="number">111</span>],f[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=<span class="number">0</span>||y&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y]!=<span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">return</span> f[x][y]=a[x][y]+<span class="built_in">max</span>(<span class="built_in">dfs</span>(x<span class="number">-1</span>,y),<span class="built_in">dfs</span>(x<span class="number">-1</span>,y<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(n,i));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反过来思考，从上往下递推，可以发现，如果在求A位置的最大路径和，而又已知左上B和右上C位置的最大路径和，那么在B和C中取更大的，加上A位置的local值，显然即为A位置的最大路径和。由此，可以从上到下按顺序将每个位置的答案求出，时间复杂度$O(n^2)$。这种<strong>递推</strong>的方法被称为<strong>动态规划</strong>。（《算法导论》中称为bottom-up method）</p>
<p>根据“介绍”中给的methodology，我们可以这样看这道题目：</p>
<ol>
<li>把求解过程分解为若干个子问题，即到各个位置的最大路径和问题</li>
<li>确定状态：定义$f[i][j]$的含义为从第一行第一列到第$i$行$j$列位置的最大路径和</li>
<li>确定初始状态：$f[1][1]=a[1][1]$</li>
<li>状态转移方程：$f[i][j]=a[i][j]+max{f[i-1][j],f[i-1][j-1]}$</li>
</ol>
<p>显然这道题具有最优子结构性质，也即依靠子问题的最优答案可以直接获得总体的最优答案</p>
<p>显然这道题具有无后效性，后续选择不会影响之前选择的最优性质</p>
<p>样例数据的递推结果（也即记忆化搜索存下来的答案）</p>
<p>7<br>10 15<br>18 16 15<br>20 25 20 19<br>24 30 27 26 24</p>
<p>对于许多题目，记忆化搜索与递推动态规划都可以作为题目的正确解法，区别仅在于代码实现的复杂度以及搜索所带来的爆栈问题。</p>
<p>大部分DP题都可以模型化成类似的形式，在做后面题目的时候注意应用这样的分析方法，和这道题做比较哦！</p>
<h5 id="参考代码（DP递推）"><a href="#参考代码（DP递推）" class="headerlink" title="参考代码（DP递推）"></a>参考代码（DP递推）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,ans,a[<span class="number">111</span>][<span class="number">111</span>],f[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            f[i][j]=a[i][j]+<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>如何设计状态？这道题不像数字三角形一样，即使没学过DP也很简单地能设计出状态和转移方程。</p>
<p>可以首先观察这道题中可能可以作为状态的变量：当前已用的时间、可选的草药范围、已取的草药价值</p>
<p>所以我们尝试这样设计：</p>
<p>状态：设$f[i][j]$表示只考虑前$i$种草药的情况下，用$j$时间time（其中部分时间可能是空闲的）所能采到的最大草药价值value</p>
<p>转移方程：$f[i][j]=max{f[i-1][j-t[i]]+v[i],f[i-1][j]}$，max函数中的两项分别代表了取$i$的情况和不取$i$的情况</p>
<p>初态$f[x][0]=0$不管在哪些草药中选择，不花时间肯定采不到草药。</p>
<p>最终答案显然为$f[M][T]$</p>
<p>时间复杂度$O(MT)$，即可解决问题</p>
<h5 id="参考代码（最直观的设计）"><a href="#参考代码（最直观的设计）" class="headerlink" title="参考代码（最直观的设计）"></a>参考代码（最直观的设计）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> M,T,v[<span class="number">11111</span>],t[<span class="number">11111</span>],f[<span class="number">11111</span>][<span class="number">11111</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;T&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) cin&gt;&gt;t[i]&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=T;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j-t[i]&gt;=<span class="number">0</span>) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-t[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;f[M][T]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，毕竟有三个可以作为状态的量。如果我们换一种设计呢？</p>
<p>状态：$f[i][j]$表示前$i$种草药中选择价值为$j$的草药，所花的最短时间</p>
<p>转移方程$f[i][j]=min{f[i-1][j-v[i]]+t[i],f[i-1][j]}$</p>
<p>初始状态：$f[x][0]=0$，其余为正无穷（将数组预处理为一个不会影响答案的大数即可）</p>
<p>最终答案即为$f[i][j]&lt;T$可能取到的最大的$j$</p>
<p>时间复杂度$O(M\sum v_i)$</p>
<p>这里其实用到了一些贪心的想法。如何证明这样的算法是正确的？</p>
<h5 id="参考代码（另外一种解法）"><a href="#参考代码（另外一种解法）" class="headerlink" title="参考代码（另外一种解法）"></a>参考代码（另外一种解法）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> M,T,v[<span class="number">11111</span>],t[<span class="number">11111</span>],f[<span class="number">11111</span>][<span class="number">11111</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;T&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) cin&gt;&gt;t[i]&gt;&gt;v[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));<span class="comment">//memset是逐字节填充，因此填0x3f就能把f变成都是0x3f3f3f3f的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=M;i++) f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10000</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j-v[i]&gt;=<span class="number">0</span>) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+t[i]);</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]&lt;=T) ans=<span class="built_in">max</span>(ans,j);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果这道题的数据范围有变化，比如$T$很大的话就不能用第一种设计，总价值很大的话就不能用第二种设计。因此，在设计好状态之后，不仅应该判断这样的设计在代码实现上可不可行、正确性能否保证，还必须分析复杂度，并根据题目的数据范围分析可不可行。</p>
<h4 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h4><p>空间复杂度的限制虽然在很多算法题中没有体现，但也是一般编程中必须考虑的问题。以第一种解法为例，我们可以发现，在$i$不断增大的过程中，我们只需要用到$f[i-1]$中的信息，而不需要$f[1\sim i-2]$中的任何数据。所以我们可以尝试把$f$数组改成两行的数组f[2][11111]：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) </span><br><span class="line">&#123;</span><br><span class="line">    now^=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//for (int j=T;j&gt;=0;j--) 如果for循环这样写，改变j的枚举顺序，显然不会影响答案的正确性。但这样的修改可以让我们有下面的进一步优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=T;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[now][j]=f[now^<span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j-t[i]&gt;=<span class="number">0</span>) f[now][j]=<span class="built_in">max</span>(f[now][j],f[now^<span class="number">1</span>][j-t[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[now][T]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>我们知道，在计算机运行程序的时候，一维数组的寻址就是一次size_t的加法，而二维数组的寻址却是一次乘法和一次加法，因此二维数组寻址会慢得多。上面这种方法中编译器很可能会将两行的二维数组寻址优化为一维数组寻址，但是我们也不确定编译器的行为。那能否将代码优化成真正的一维数组呢？这道题中当然是可以的，但是需要注意$j$的枚举方向，不能把需要的数据覆盖了。在上面的方法中，要计算$f[now][j]$的值，只需要知道$f[other][&lt;j]$的值，因此我们可以改变枚举顺序，用$j$从大到小的顺序计算$f[now][j]$，使得不再需要区分$now$和$other$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=T;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        <span class="keyword">if</span> (j-t[i]&gt;=<span class="number">0</span>) f[j]=<span class="built_in">max</span>(f[j],f[j-t[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[T]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>一下子想不清楚的话可以带入一组样例并手推或者把每一步的结果打印出来看看。</p>
<p>在时间和空间都不断优化的过程中，我们的代码也越来越短，真奇妙！</p>
<p>上面的另一种设计方法也可以利用滚动数组优化，可以自己试试。</p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>子序列即在原序列中选择一部分元素。</p>
<p>两个可以用作状态设计的值为：从第一个序列中的前$i$个中选择，从第二个序列中的前$j$个中选择。</p>
<p>状态转移方程很容易列出</p>
<p>更具体的解题过程与证明可以看《算法导论》</p>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5555</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn],t[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>)&gt;&gt;(t+<span class="number">1</span>);<span class="comment">//为了避免访问到负数位置</span></span><br><span class="line">    <span class="keyword">int</span> l1=<span class="built_in">strlen</span>(s+<span class="number">1</span>),l2=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l1;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> (s[i]==t[j]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;f[l1<span class="number">-1</span>][l2<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>有了前几题的经验，我们可以先列一下什么变量可能可以拿来设计状态：</p>
<p>从序列的前$i$个元素中选择、上升子序列的长度、上升子序列末尾位的大小</p>
<p>很直观地想到这两种状态设计：</p>
<h5 id="设计一"><a href="#设计一" class="headerlink" title="设计一"></a>设计一</h5><p>定义$f[i][j]$为从序列前$i$个中取，末尾值为$j$时的最长上升子序列长度</p>
<p>转移方程：$f[i][j]=\max {f[i-1][&lt;j]}+1$</p>
<p>但是$j$的取值范围是$10^9$，看似无法解决这道题。实际上，这里可以应用一种被称作“离散化”的方法：由于原数组最多只有$10^6$种取值，且只要数组元素之间的大小关系不变，最终答案就是不变的，因此我们可以从小到大给原数组重新赋值（或者说是映射）成1，2，3，…，n。而这个过程可以利用STL中的map/unordered_map或是自己实现平衡树或哈希表解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将a数组离散化</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]=a[i];</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> nn=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nn;i++) m[b[i]]=i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=m[a[i]];</span><br></pre></td></tr></table></figure>

<p>那么，将$j$的取值范围从$10^9$优化到$10^6$之后，显然我们的问题还没有解决。先尝试写一下核心部分的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)    &#123;        <span class="keyword">int</span> temp=<span class="number">0</span>;        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;j;k++) temp=<span class="built_in">max</span>(temp,f[i<span class="number">-1</span>][k]);        f[i][j]=temp+<span class="number">1</span>;    &#125;</span><br></pre></td></tr></table></figure>

<p>看似需要$O(n^3)$的时间复杂度才能解决。</p>
<p>但这里我们可以使用一种非常简单高效的优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)    &#123;        f[i][j]=m[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;        m[i][j]=<span class="built_in">max</span>(f[i][j],m[i][j<span class="number">-1</span>]);    &#125;</span><br></pre></td></tr></table></figure>

<p>通过设计一个数组m存储f的前缀max值（$m[i][j]=\max{f[i][k]},k\in [1,j]$），将复杂度优化至$O(n^2)$。但$n$的范围$10^6$仍然让我们望而却步。</p>
<h5 id="设计二"><a href="#设计二" class="headerlink" title="设计二"></a>设计二</h5><p>定义$f[i][j]$为从序列前$i$个中取，规定上升子序列长度为$j$时的最小末尾值（无穷大表示不存在这样的子序列）</p>
<p>转移方程：<br>$$<br>\begin{cases}<br>f[i][j]=\min {f[i-1][j],a[i]},~~~f[i-1][j-1]&lt;a[i]且i\not=j<br>\<br>f[i][j]=f[i-1][j],~~~~~~~~~~~~~~~~~~~~~f[i-1][j-1]\ge a[i]且i\not=j\<br>f[i][j]=a[i],~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~f[i-1][j-1]&lt;a[i]且i=j\<br>f[i][j]=\infin,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~f[i-1][j-1]\ge a[i]且i=j<br>\end{cases}<br>$$<br>这样我们就又得到了一种$O(n^2)$的算法。</p>
<h5 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span>using namespace std;const int maxn=5555;int n,f[maxn][maxn],a[maxn];int main()&#123;	cin&gt;&gt;n;	for (int i=1;i<span class="meta-string">&lt;=n;i++) cin&gt;</span>&gt;a[i];	f[0][0]=0x3f3f3f3f;	int ans=0;	for (int i=1;i&lt;=n;i++)	&#123;		for (int j=1;j&lt;=i;j++)		&#123;			<span class="meta-keyword">if</span> (i==j) 			&#123;				<span class="meta-keyword">if</span> (f[i-1][j-1]&lt;a[i]||j==1) f[i][j]=a[i];				<span class="meta-keyword">else</span> f[i][j]=0x3f3f3f3f;			&#125;			<span class="meta-keyword">else</span> <span class="meta-keyword">if</span> (f[i-1][j-1]&lt;a[i]) f[i][j]=min(f[i-1][j],a[i]);			<span class="meta-keyword">else</span> f[i][j]=f[i-1][j];			<span class="comment">//cout&lt;&lt;f[i][j]&lt;&lt;&#x27; &#x27;;			if (f[i][j]!=0x3f3f3f3f) ans=max(ans,j);		&#125;		//cout&lt;&lt;endl;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>



<p>突破口在哪里？寻找$f$数组可以利用的性质。可以发现，当$f[i][j]$中$j$增大时，最小末尾值必定增大，也就是说$f[i]$是单调递增的。而且$f[i]$与$f[i-1]$只有一个位置不同，即$f[i-1][j-1]$与$a[i]$大小关系的临界点处。（可以写个程序跑一跑输出一下试试，并想一想为什么）</p>
<p>这样的有序数列找位置问题可以利用二分查找解决。</p>
<p>由此，我们找到了一个优化：定义$f[x]$表示长度为$x$的上升子序列的最小末尾值(为了防止与上面说的$i$相混淆，这里用了$x$)</p>
<p>状态转移方程比较难表示，但代码很简短。具体参看代码。</p>
<h5 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>using namespace std;const int maxn=1111111;int n,a[maxn],f[maxn];int main()&#123;	scanf(<span class="meta-string">&quot;%d&quot;</span>,&amp;n);	for (int i=1;i&lt;=n;i++) scanf(<span class="meta-string">&quot;%d&quot;</span>,a+i);	memset(f,0x3f,sizeof(f));<span class="comment">//将f的所有项赋值为无穷大	f[0]=0;	int ans=0;	for (int i=1;i&lt;=n;i++)	&#123;		int pos=upper_bound(f,f+n+1,a[i]-1)-f;		ans=max(ans,pos);		f[pos]=min(f[pos],a[i]);	&#125;	printf(&quot;%d\n&quot;,ans);	return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>从这道题我们又得到了启发：不同的状态设计可能某些可以优化，某些却难以更进一步。当你在一种设计中绕啊绕的时候，不妨想一想别的设计方法。</p>
<h3 id="卡牌游戏"><a href="#卡牌游戏" class="headerlink" title="卡牌游戏"></a>卡牌游戏</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>应该怎么设计状态？我们很直观地可以得到一些设计的方法：</p>
<p>比如$f[i][j]$表示左边已经被取了$i$个，右边被取了$j$个时的先手最大值。但是这样设计出来的并不是动态规划所需要的“子问题”。即使求出了$f$的所有项，也无法得到所需的最终答案。</p>
<p>对于这种问题，我们有一个比较常用的思路：定义$f[i][j]$为只考虑从第$i$个到第$j$个这一段的双方最优情况下先手取到的值，那么最终答案显然是$f[1][n]$。（注意：这里所说的先手指的是只考虑这一段的局部先手，即假设整个游戏只有这一段时拿第一个的人，而不是特指题目条件中的那个先手玩家）</p>
<p>但是状态转移方程是什么呢？由于这道题有先手方和后手方，他们会有不一样的决策，很难直接想出转移的式子。于是我们考虑$f[i][j]$所依赖的是哪些子问题。在$f[i][j]$中，先手需要选择取$a[i]$还是取$a[j]$。取完之后，先手玩家将会变成后手玩家，段长也小了1（从$i$到$j-1$或者从$i+1$到$j$）。所以我们需要知道这两种情况下后手玩家（与$f[i][j]$情况下的先手是同一个人）所拿到的值，就能分析出$f[i][j]$情况下先手应该拿第$i$个还是第$j$个。</p>
<p>那么我们考虑再引入$g[i][j]$，表示从$i$到$j$这段的双方最优决策下，后手所取到的值。</p>
<p>那么转移方程就比较显然了：</p>
<p>$f[i][j]$的状态有拿走左边或者拿走右边两种选择，而先手方一定选择结果更大的一种情况。拿完这一步之后，先手方就会变成下一步情况下的后手方，接下来能拿到的最大值即$g[i+1][j]$或$g[i][j-1]$的值。</p>
<p>而对于$g[i][j]$来说，此时先手想要自己最大也即对方最小（因为总和是一定的），就是希望自己拿完这一步后到达的$f[i+1][j]$或$f[i][j-1]$最小。<br>$$<br>f[i][j]=\max{g[i+1][j]+a[i],g[i][j-1]+a[j]}\<br>g[i][j]=\min{f[i+1][j],f[i][j-1]}<br>$$<br>注意一下$i$和$j$的枚举顺序即可。可以像下面参考代码一样的顺序，也可以把$j-i$（即段长）作为枚举变量，由短至长进行枚举。想清楚枚举顺序想必并不是那么难。</p>
<h5 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;const int maxn=3333;int n,a[maxn];long long f[maxn][maxn],g[maxn][maxn];int main()&#123;	cin&gt;&gt;n;	for (int i=1;i<span class="meta-string">&lt;=n;i++) 	&#123;		cin&gt;</span>&gt;a[i];		f[i][i]=a[i];	&#125;	for (int j=1;j<span class="meta-string">&lt;=n;j++)		for (int i=j-1;i&gt;</span>=1;i--)		&#123;			g[i][j]=min(f[i+1][j],f[i][j-1]);			f[i][j]=max(g[i+1][j]+a[i],g[i][j-1]+a[j]);		&#125;	cout&lt;&lt;f[1][n]&lt;&lt;endl;	return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这道题我们在状态设计中尝试引入了$f$和$g$两个以便于分析，这是很多偏难的问题中必备的方法。</p>
<h3 id="NOI1995-石子合并"><a href="#NOI1995-石子合并" class="headerlink" title="[NOI1995] 石子合并"></a>[NOI1995] 石子合并</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>状态：定义$f[i][j]$为从$i$到$j$这段合并的花费</p>
<p>转移方程：$f[i][j]=\min{f[i][k]+f[k+1][j]+sum(i,j)},k\in [i,j-1]$</p>
<p>注意$i,j$的枚举顺序即可，和上一题类似，只要别让先算的项要依赖后算的项才能算出正确答案就行。</p>
<p>这样我们就得到了一个$O(n^3)$的算法，80分。但是本题需要$O(n^2)$以下才能拿到更多分数，涉及到高深的四边形不等式优化，有兴趣的读者可以在网络上学习。</p>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4444</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],s[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> s[r]-s[l<span class="number">-1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=i;k&lt;j;k++) </span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+<span class="built_in">sum</span>(i,j));</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整齐打印"><a href="#整齐打印" class="headerlink" title="整齐打印"></a>整齐打印</h3><p>和上一题有一点相似但也不是很相似。这里只贴一份参考代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,l[maxn],s[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cube</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)x*x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">cube</span>(m-r+l-(s[r]-s[l<span class="number">-1</span>]));&#125;<span class="comment">//如果把l到r这段放在同一行，将会产生多少花费</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;l[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="number">-1</span>]+l[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp=<span class="built_in">w</span>(j,i);</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;=<span class="number">0</span>) f[i]=<span class="built_in">min</span>(f[i],temp+f[j<span class="number">-1</span>]);<span class="comment">//如果最后一行也要算花费，那么前i个单词隔成任意行后的总花费最小是多少</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=f[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">w</span>(i,n)&gt;=<span class="number">0</span>) ans=<span class="built_in">min</span>(ans,f[i<span class="number">-1</span>]);<span class="comment">//从第i个单词开始到最后一个单词都放在最后一行的话，总答案将会是多少（因为最后一行的空格不算进答案）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h2><h3 id="双调巡游"><a href="#双调巡游" class="headerlink" title="双调巡游"></a>双调巡游</h3><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>网上有很多本题的解析，思路比较常规。</p>
<p>这里提供一种不一样的思考</p>
<p><a target="_blank" rel="noopener" href="https://www.jxtxzzw.com/archives/3493">类似方法的一篇博客https://www.jxtxzzw.com/archives/3493</a>他讲得篇幅较大，也比较清楚</p>
<p>下面代码的思路：首先将双调巡游过程看成两个人A和B从排好序后的1号点走到n号点，他们路上经过的点均不重复。那么这两个人是相互等价的，交换身份后答案仍然相同。而这个过程中相当于各个点只是需要被分配给A走或分配给B走。（在下面，我默认某个点分配了就是人走到了）</p>
<p>定义$f[i][j]$表示走得慢的人走到了$i$处，且前$i$个点都已经被分配（模拟两个人向右走的过程，那么如果前$i$个点没被分配完，他们也不能回头去走了）、快的人已经走到第$j$个的位置（但不经过$i$到$j$之间的任何点）时的最小花费。</p>
<p>囿于笔者文字水平限制，读者请尽量意会一下。</p>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pair&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt; p[maxn];</span><br><span class="line"><span class="keyword">float</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sqr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt; &amp;a,<span class="keyword">const</span> pair&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(a.first-b.first)+<span class="built_in">sqr</span>(a.second-b.second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i].first&gt;&gt;p[i].second;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) f[<span class="number">1</span>][i]=<span class="built_in">dis</span>(p[<span class="number">1</span>],p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][j]+<span class="built_in">dis</span>(p[i<span class="number">-1</span>],p[i]),f[i<span class="number">-1</span>][i]+<span class="built_in">dis</span>(p[i<span class="number">-1</span>],p[j]));</span><br><span class="line">            <span class="comment">//第一种是给走得慢的人直接分配下一个点（因为所有点都需要被分配，他不能跳着走），第二种是让走得快的人跳着走一步。</span></span><br><span class="line">    cout&lt;&lt;f[n][n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="Easy-1"><a href="#Easy-1" class="headerlink" title="Easy"></a>Easy</h2><h3 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h3><p>可以发现，这样的问题和数据结构课程中的哈夫曼树构建过程几乎一模一样。利用STL的priority_queue（内部是用堆实现的）或者自己写个堆即可轻松解决，时间复杂度$O(n\lg n)$。上机考试/比赛遇到类似的题目时可以瞎猜结论交上去，比如这道题的结论就很符合我们的直觉：不断地把最小的两堆合并。但是作为平时、作为这门算法分析课程的题目而言，我们需要研究证明这样的算法为什么正确。参见《算法导论》以及网络上各种哈夫曼树最优性证明，此处不多赘述。</p>
<h4 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; h;<span class="comment">//heap </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        h.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=h.<span class="built_in">top</span>();</span><br><span class="line">        h.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> b=h.<span class="built_in">top</span>();</span><br><span class="line">        h.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=a+b;</span><br><span class="line">        h.<span class="built_in">push</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="铺设道路"><a href="#铺设道路" class="headerlink" title="铺设道路"></a>铺设道路</h3><h4 id="算法设计与证明"><a href="#算法设计与证明" class="headerlink" title="算法设计与证明"></a>算法设计与证明</h4><p>做题时的思路：</p>
<p>发现如果右边一段比左边深的话，就一定产生花费；如果比左边一段浅或者相同，就可以趁左边的填充的同时一起填，不产生花费。凭感觉这样就是最优的。构造几组数据发现都是对的，那它多半就是对的，先交了试试。</p>
<p>一种证明思路：</p>
<p>设深度数组为$a$，其中增加一项$a[0]=0$和一项$a[n+1]=0$，定义差分数组$d[i]=a[i]-a[i-1]$。则将道路填平即等价于将$d[1\sim n+1]$都变成$0$。由于每一次填充操作最多将$d$的一位$+1$，另一位$-1$，因此填充次数$m\ge \sum_{d[i]&gt;0} d[i]$才可能达成目标。下面证明必定存在填充次数$m=\sum_{d[i]&gt;0} d[i]$的可行方法。</p>
<p>首先，由于$a[0]=a[n+1]=0$，因此$\sum_{i=1}^{n+1}d[i]=0$，而每一次填充操作都可以将一个正数$d[l]-1$，同时将一个负数$d[r]+1$，其中$l&lt;r$。但填充操作并不是可以任意选择的，是有限制条件的：$l$和$r$之间（包括$l$，不包括$r$）的每个位置此时的深度都不为$0$。现在我们提供一种方法：每一次操作都将大于0的第一个，记为$d[l]$的值-1；将第一个小于0的记为$d[r]$的值+1。如果能证明这样的方法必定可行，那就证明了存在$m=\sum_{d[i]&gt;0} d[i]$的方法。</p>
<p>假设这样选择的$l$和$r$之间存在深度为$0$的位置$k$，则$\sum_{i=1}^k d[i]=a[k]=0$。而$l\le k&lt;r,d[l]&gt;0$，因此<br>$$<br>(\sum_{i=1}^{k}d[i])-d[l]=-d[l]\<br>\sum_{i=1}^{l-1}d[i]+\sum_{i=l+1}^{k}d[i]&lt;0\<br>$$<br>故$d[1\sim k]$中必有至少一项小于$0$，与“$d[r]$是最左边的一个小于$0$的”矛盾。</p>
<h4 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">111111</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (a[i]&gt;a[i<span class="number">-1</span>]) ans+=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="Medium-1"><a href="#Medium-1" class="headerlink" title="Medium"></a>Medium</h2><h3 id="卡牌游戏-1"><a href="#卡牌游戏-1" class="headerlink" title="卡牌游戏"></a>卡牌游戏</h3><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>田忌赛马。对于Rachel的每一张牌，都尝试用刚好小一点的牌去对抗，因为太小的就比较“浪费”。这样的思路很符合我们的直觉。代码利用STL的map可以很方便实现。</p>
<p>对这种方法的证明：</p>
<p>由于每张牌的出牌顺序与答案无关，对Rachel的牌排序之后就可以邻项交换法（证明这种分配方式在交换相邻两个选择后只会使结果不变或更劣）很方便证明。但是不排序、直接做也是可以保证正确性的，因为这时候牌与牌之间没有顺序，可以把上面的邻项交换法稍微改动一下——任意两项交换后，能证明结果都是不变或者更劣的。</p>
<p>Hard部分的“国王游戏”一题将利用邻项交换法证明，作为这种方法的一个例子。</p>
<h4 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">111111</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,m,ans;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; w;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[y]+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it=w.<span class="built_in">lower_bound</span>(a[i]);<span class="comment">//it是大于等于a[i]的第一个位置，我们要找的是小于a[i]的最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (it!=w.<span class="built_in">begin</span>())<span class="comment">//如果相等就说明没有比a[i]更小的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            --it;</span><br><span class="line">            ++ans;</span><br><span class="line">            it-&gt;second--;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second==<span class="number">0</span>) w.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h3><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>刚开始的$k$个直接放进缓存。之后每遇到一个不在缓存中的数x，都与缓存中下一次出现位置最远的数y相比较，如果x将会更快出现，则替换之，否则不替换。实现时应先预处理出每个位置的数的下一次出现位置。利用priority_queue就可以解决问题。</p>
<p>证明：</p>
<p><a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/courses/archive/spr05/cos423/lectures/04greed.pdf">https://www.cs.princeton.edu/courses/archive/spr05/cos423/lectures/04greed.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.henrypoon.com/blog/2014/02/02/proof-of-the-farthest-in-future-optimal-caching-algorithm/">https://blog.henrypoon.com/blog/2014/02/02/proof-of-the-farthest-in-future-optimal-caching-algorithm/</a></p>
<p>（笔者怕自己水平不够，写出来的东西容易让人看不懂，故找了看起来较合适的证明贴于此处）</p>
<h3 id="蛤"><a href="#蛤" class="headerlink" title="蛤"></a>蛤</h3><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>首先想到一个朴素贪心：模拟每只蛤的跳跃过程，一只接一只模拟，跳的时候每次都尽量跳得更远。</p>
<p>证明：</p>
<p>假设有$l$，$r$两块石头，其中$l$在$r$左边，$L$，$R$两只蛤，$L$在$R$左边，且$l$，$r$均在$R$右边。第一种情况：$L$能够跳到$l$和$r$，那么$R$一定也能跳到这两块石头，那么不管$L$跳到哪块，$R$跳到另一块，结果都是一样的（因为两只蛤是等价的，跳完的结果都是$l$和$r$的位置上各有一只蛤），不会更劣。第二种情况：$L$能够跳到$l$但跳不到$r$，那么如果$R$选择跳到$l$，就会导致$L$无处可跳，因此$R$跳到更远的$r$是更优的。第三种情况：$L$无法跳到$l$和$r$的任何一个，那么$R$无论跳到哪里，也改变不了$L$无法继续前进的情况，因此$R$的决策也不会使结果更劣。综上，$R$选择尽量远的能跳到的石头不会更劣，只可能更优。因此每次都跳得尽量远是使得最多蛤能过河的方法。</p>
<p>但是这样直接模拟的时间复杂度将会是$O(mn)$的，无法通过。</p>
<p>我们可以换一种思考方式。既然让蛤跳到离它最远的石头是最优的，其实也很容易证明，将每块石头依次分配给离它最远的蛤是最优的（按照上面证明步骤中的假设，即$l$应当选择让$L$跳过来会是可能更优、不会更劣的）（也很容易证明：每块石头都被用到比一部分石头不被用到 不会更劣）。刚才的方法是蛤选择跳哪个石头，现在的方法是石头选择让哪只蛤跳过来。也就是说，</p>
<p><img src="/.io//image-20220127222024873.png" alt="image-20220127222024873"></p>
<p><img src="/.io//image-20220127222114181.png" alt="image-20220127222114181"></p>
<p><img src="/.io//image-20220127222146697.png" alt="image-20220127222146697"></p>
<p>图中所示这样的方法也是一种最优的方案。</p>
<p>可以利用队列存储蛤们的位置，按顺序枚举石头，保持队列中的蛤的位置是递增的（每一只蛤改变位置之后都插到最后去)。如果队首的蛤跳不到最近的没跳过的石头，那它就到不了对岸。</p>
<h4 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1111111</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,D,L,a[maxn],T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;D,&amp;L);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    	a[n+<span class="number">1</span>]=L;</span><br><span class="line">    	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">   		&#123;</span><br><span class="line">        	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()+D&lt;a[i]) q.<span class="built_in">pop</span>();</span><br><span class="line">        	q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (q.<span class="built_in">size</span>()==m) <span class="built_in">puts</span>(<span class="string">&quot;Excited&quot;</span>);</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hard-1"><a href="#Hard-1" class="headerlink" title="Hard"></a>Hard</h2><h3 id="国王游戏"><a href="#国王游戏" class="headerlink" title="国王游戏"></a>国王游戏</h3><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>设众人左手上的数为$a[i]$，右手为$b[i]$，得到的奖赏为$v[i]$。则利用邻项交换法推导，<br>$$<br>v[i]=\frac{\prod_{j=0}^{i-1}a[j]}{b[i]}\<br>若将其中的第p项与第p+1项交换\<br>设s=\prod_{j=0}^{p-1}a[j]\<br>v[p]=\frac s {b[p]},v[p+1]=\frac{s\cdot a[p]}{b[p+1]}\<br>交换后v’[p]=\frac s {b[p+1]},v’[p+1]=\frac{s\cdot a[p+1]}{b[p]}\<br>式1:若\max{\frac 1 {b[p]},\frac{a[p]}{b[p+1]}}&gt;\max{\frac{1}{b[p+1]},\frac{a[p+1]}{b[p]}}，则一定是交换后更优(奖赏的最大值可能更小)\<br>由于a[p+1]\ge 1,a[p]\ge 1,故\frac{a[p+1]}{b[p]}\ge\frac 1 {b[p]},\frac{a[p]}{b[p+1]}\ge\frac{1}{b[p+1]}\<br>故只有当\frac{a[p+1]}{b[p]}&lt;\frac{a[p]}{b[p+1]}时，式1才会成立,交换后才会更优\<br>即a[p]\cdot b[p]&gt;a[p+1]\cdot b[p+1]时应当交换\<br>故应当按照a[x]\cdot b[x]的值排序，贪心选取<br>$$<br>但本题需要高精度才能拿到满分，但那不是本题的重点。</p>
<h4 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h4><p>没写高精度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1111</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;x,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)x.first*x.second&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)y.first*y.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) cin&gt;&gt;d[i].first&gt;&gt;d[i].second;</span><br><span class="line">    <span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now=d[<span class="number">0</span>].first,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,now/d[i].second);</span><br><span class="line">        now*=d[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这一段主要讲述建模方法，由于求解方法在《算法导论》中已有比较详细的阐述。下文默认读者已经了解二分图匹配和最大流问题的基本定义和实现方法。</p>
<p>给出的建模方法都只是示例，可能有其它结果相同的建模方法，比如很多情况下将所有边反向后的答案不变。</p>
<p>最大流问题的建模方法大致可以分为利用最大流的思路建模以及利用最小割的思路建模。其中最小割思路常常应用于“在一些物品中选择一些已得到最优结果”时，不选择物品在建模中的体现便是被割掉，选择该物品则是对应的边不被割掉。</p>
<p>笔者所用的最大流ISAP算法（dinic的改进算法）模板（使用数组模拟的链式前向星存图法，一般只会在竞赛中使用而几乎没有实际使用价值，请读者不要盲目模仿）以及其它宏定义如下。为避免篇幅过长，每道题的参考代码中将不再复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//by Richard</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cls(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x,y,z) for (int x=(y);(x)&lt;=(z);(x)++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(x,y,z) for (int x=(y);(x)&gt;=(z);(x)--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pairs;</span><br><span class="line"><span class="comment">///////////////////////read5.1///////////////////////</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;<span class="keyword">char</span> ch;x=<span class="number">0</span>;<span class="keyword">bool</span> flag=<span class="literal">false</span>;ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="literal">true</span>;ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span> ((ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>))&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">if</span> (flag) x*=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x,U &amp;y)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U,<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x,U &amp;y,V &amp;z)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);&#125;</span><br><span class="line"><span class="comment">////////////////variables&amp;functions//////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">10000</span>,MAXE=<span class="number">40000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GRAPH</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    EDGE edge[MAXE];</span><br><span class="line">    <span class="keyword">int</span> next[MAXE],first[MAXV],cnt,v=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> vv)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(first,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(first));</span><br><span class="line">        <span class="built_in">cls</span>(edge);<span class="built_in">cls</span>(next);</span><br><span class="line">        cnt=<span class="number">-1</span>;v=vv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        edge[++cnt].u=u;edge[cnt].v=v;</span><br><span class="line">        edge[cnt].w=w;next[cnt]=first[u];</span><br><span class="line">        first[u]=cnt;edge[++cnt].u=v;</span><br><span class="line">        edge[cnt].v=u;edge[cnt].w=<span class="number">0</span>;</span><br><span class="line">        next[cnt]=first[v];first[v]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;graph;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SAP</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> current[MAXE],distance[MAXV],layer[MAXV],last[MAXV],pred[MAXV];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,graph.v)</span><br><span class="line">    &#123;</span><br><span class="line">        current[i]=graph.first[i];</span><br><span class="line">        distance[i]=layer[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=S,now_flow=inf,total_flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (distance[S]&lt;graph.v)</span><br><span class="line">    &#123;</span><br><span class="line">    xxx:</span><br><span class="line">        last[i]=now_flow;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=current[i];k!=<span class="number">-1</span>;k=graph.next[k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=graph.edge[k].v;</span><br><span class="line">            <span class="keyword">if</span> ((!graph.edge[k].w)||distance[i]!=distance[j]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            current[i]=k;</span><br><span class="line">            <span class="keyword">int</span> cur_flow=graph.edge[k].w;</span><br><span class="line">            now_flow=<span class="built_in">min</span>(cur_flow,now_flow);</span><br><span class="line">            pred[j]=i;</span><br><span class="line">            i=j;</span><br><span class="line">            <span class="keyword">if</span> (i==T)</span><br><span class="line">            &#123;</span><br><span class="line">                total_flow+=now_flow;</span><br><span class="line">                <span class="keyword">while</span> (i!=S)</span><br><span class="line">                &#123;</span><br><span class="line">                    i=pred[i];</span><br><span class="line">                    graph.edge[current[i]].w-=now_flow;</span><br><span class="line">                    graph.edge[current[i]^<span class="number">1</span>].w+=now_flow;</span><br><span class="line">                &#125;</span><br><span class="line">                now_flow=inf;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> xxx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_dis=graph.v<span class="number">-1</span>,min_place=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=graph.first[i];k!=<span class="number">-1</span>;k=graph.next[k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=graph.edge[k].v;</span><br><span class="line">            <span class="keyword">if</span> (graph.edge[k].w&amp;&amp;distance[j]&lt;min_dis)</span><br><span class="line">            &#123;</span><br><span class="line">                min_dis=distance[j];</span><br><span class="line">                min_place=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current[i]=min_place;</span><br><span class="line">        layer[distance[i]]--;</span><br><span class="line">        <span class="keyword">if</span> (!layer[distance[i]]) <span class="keyword">break</span>;<span class="comment">//gap</span></span><br><span class="line">        distance[i]=min_dis+<span class="number">1</span>;</span><br><span class="line">        layer[distance[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (i!=S) &#123;i=pred[i];now_flow=last[i];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Naive-1"><a href="#Naive-1" class="headerlink" title="Naive"></a>Naive</h2><h3 id="搭配飞行员"><a href="#搭配飞行员" class="headerlink" title="搭配飞行员"></a>搭配飞行员</h3><p>本题完全符合二分图匹配的定义。直接利用匈牙利算法求解即可。</p>
<p>当然，二分图匹配问题均可转化为最大流问题。建立一个超级源点S(source)和一个超级汇点T(terminal)，从S向每一个正驾驶员都连一条流量为1的边，从每一个副驾驶员向T连一条流量为1的边，并从配对的正驾驶员向副驾驶员连边。最大流的答案即二分图匹配的答案。</p>
<p>下面是网上找的图片 第一张是二分图匹配的建模方式，第二张是最大流的建模方式</p>
<p><img src="https://img-blog.csdnimg.cn/20190727163211174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjI3MDM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190727163606708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjI3MDM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> did1[MAXV],did2[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    graph.<span class="built_in">init</span>(n+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;u&gt;&gt;v) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!did1[u])</span><br><span class="line">        &#123;</span><br><span class="line">            did1[u]=<span class="literal">true</span>;</span><br><span class="line">            graph.<span class="built_in">addedge</span>(n+<span class="number">2</span>,u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!did2[v])</span><br><span class="line">        &#123;</span><br><span class="line">            did2[v]=<span class="literal">true</span>;</span><br><span class="line">            graph.<span class="built_in">addedge</span>(v,n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        graph.<span class="built_in">addedge</span>(u,v,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">SAP</span>(n+<span class="number">2</span>,n+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Easy-2"><a href="#Easy-2" class="headerlink" title="Easy"></a>Easy</h2><h3 id="试题库"><a href="#试题库" class="headerlink" title="试题库"></a>试题库</h3><p>最大流基础建模方法。将每道题都看成点，将每个类别也看成点，再设一个超级源点S和一个超级汇点T。从S向每道题连一条容量为1的边，从每道题向所属的各个类别分别连容量为1的边，从各个类别向T连容量为所需题数的边。判断最大流是否等于m即可。</p>
<p>本题的另一个要求是输出方案。判断最大流算法结束后S向每道题连的边的流量，若1则选中该题，若0则未选中。</p>
<h4 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,k,a[MAXV],m,p[MAXV];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[MAXV],ans[MAXV];</span><br><span class="line"><span class="keyword">int</span> S,T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q=graph.first[x];q!=<span class="number">-1</span>;q=graph.next[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=graph.edge[q].v;</span><br><span class="line">        <span class="keyword">if</span> (j==S) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (step==<span class="number">0</span>) <span class="built_in">dfs</span>(j,step+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph.edge[q].w==<span class="number">0</span>) ans[x].<span class="built_in">push_back</span>(j-k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(k,n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k) &#123;<span class="built_in">read</span>(a[i]);m+=a[i];&#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,p[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S=n+k+<span class="number">1</span>,T=n+k+<span class="number">2</span>;</span><br><span class="line">    graph.<span class="built_in">init</span>(n+k+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k) graph.<span class="built_in">addedge</span>(S,i,a[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to:v[i]) graph.<span class="built_in">addedge</span>(to,i+k,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) graph.<span class="built_in">addedge</span>(i+k,T,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="built_in">SAP</span>(S,T);</span><br><span class="line">    <span class="keyword">if</span> (flow!=m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No Solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(S,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to:ans[i]) cout&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;to;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="圆桌聚餐"><a href="#圆桌聚餐" class="headerlink" title="圆桌聚餐"></a>圆桌聚餐</h3><p>二分图多重匹配。与上面的题目非常相似的建模方法。</p>
<h4 id="参考代码-13"><a href="#参考代码-13" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    graph.<span class="built_in">init</span>(n+<span class="number">2</span>+m);</span><br><span class="line">    S=n+m+<span class="number">1</span>;T=n+m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        graph.<span class="built_in">addedge</span>(S,i,x);</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        graph.<span class="built_in">addedge</span>(i+n,T,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,m) graph.<span class="built_in">addedge</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">SAP</span>(S,T);</span><br><span class="line">    <span class="keyword">if</span> (ans==sum) cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=graph.first[i];k!=<span class="number">-1</span>;k=graph.next[k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=graph.edge[k].v;</span><br><span class="line">            <span class="keyword">if</span> (j==S) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!graph.edge[k].w) v.<span class="built_in">push_back</span>(j-n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to:v) cout&lt;&lt;to&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>首先看到这道题并不像传统的最大流题目，询问的不是最多能通过几个人，而是最短几天可以让人们都通过。乍一看似乎很难用网络流相关算法解决。然而贪心、最短路等图论常用解题思路也都无能为力。</p>
<p>考虑把题目转化成“最多能通过几个人”的问题：二分答案。（二分答案：二分最终所求的答案的值，每一轮都检查当前的mid值是否可行，从而得到最大/小的可行/不可行答案，具体可以请教网络）</p>
<p>本题在二分答案的基础上就只需要考虑这样的问题：检查当前所确定的mid天内最多能通过的人数是否大于等于总人数。</p>
<p>如果没有接触过这样的题目，可能难以马上想到建模的方法。</p>
<p>其实可以将同一个点在不同日子看成不同的点（也可以说是把原本的一个点拆成了“时间”个点），将i号点在第n天时记作i,n，如1号点在第1天时记作1,1、2号点在第3天时记作2,3</p>
<p>如果i号点到j号点存在一条容量为w的有向边，就从i,1向j,2连边，从i,2向j,3连边，从i,n向j,n+1连边，这些边的容量都是w</p>
<p>同时，对于每一个点，由于每个点都可以供任意多人停留，所以对于每个点都从i,n向i,n+1连容量为无穷的边</p>
<p>以这样的方法设置点和边，从而建立一个分层图，最大流即为最多能通过的人数。</p>
<p><img src="/.io//image-20220203202803406.png" alt="image-20220203202803406"></p>
<h4 id="参考代码-14"><a href="#参考代码-14" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m,V,E,S,T;</span><br><span class="line"><span class="keyword">int</span> x[MAXE],y[MAXE],c[MAXE];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span><span class="comment">//number of days</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    graph.<span class="built_in">init</span>((d+<span class="number">1</span>)*V);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,d) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,V) graph.<span class="built_in">addedge</span>(j+(i<span class="number">-1</span>)*V,j+i*V,inf);</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,E) graph.<span class="built_in">addedge</span>(x[j]+(i<span class="number">-1</span>)*V,y[j]+i*V,c[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SAP</span>(S,T+d*V)&gt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m,V,E);<span class="built_in">read</span>(S,T);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,E) <span class="built_in">read</span>(x[i],y[i],c[i]);</span><br><span class="line">    <span class="keyword">if</span> (S==T) &#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Medium-2"><a href="#Medium-2" class="headerlink" title="Medium"></a>Medium</h2><h3 id="逃逸问题"><a href="#逃逸问题" class="headerlink" title="逃逸问题"></a>逃逸问题</h3><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>路径互不相交等价于每个节点最多被经过一次。容易发现，只加入“每条边最多被经过一次”的限制会导致两条路径可能经过同一个节点，与本题题意不符。但最大流建模只能限制边的流量而不能限制点的流量，应该怎么办呢？</p>
<p>一个知道了就觉得很显然的方法：把每个节点拆成两个点，在两个拆出来的点之间连一条容量为1的边。</p>
<h4 id="参考代码-15"><a href="#参考代码-15" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="keyword">return</span> y+(x<span class="number">-1</span>)*n+z*n*n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">int</span> S=<span class="number">0</span>,T=<span class="number">2</span>*n*n+<span class="number">1</span>;</span><br><span class="line">    graph.<span class="built_in">init</span>(<span class="number">2</span>*n*n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        graph.<span class="built_in">addedge</span>(<span class="number">0</span>,<span class="built_in">id</span>(x,y,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        graph.<span class="built_in">addedge</span>(<span class="built_in">id</span>(i,j,<span class="number">0</span>),<span class="built_in">id</span>(i,j,<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span>) graph.<span class="built_in">addedge</span>(<span class="built_in">id</span>(i,j,<span class="number">1</span>),<span class="built_in">id</span>(i<span class="number">-1</span>,j,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i&lt;n) graph.<span class="built_in">addedge</span>(<span class="built_in">id</span>(i,j,<span class="number">1</span>),<span class="built_in">id</span>(i+<span class="number">1</span>,j,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j&gt;<span class="number">0</span>) graph.<span class="built_in">addedge</span>(<span class="built_in">id</span>(i,j,<span class="number">1</span>),<span class="built_in">id</span>(i,j<span class="number">-1</span>,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j&lt;n) graph.<span class="built_in">addedge</span>(<span class="built_in">id</span>(i,j,<span class="number">1</span>),<span class="built_in">id</span>(i,j+<span class="number">1</span>,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">1</span>||j==<span class="number">1</span>||i==n||j==n) graph.<span class="built_in">addedge</span>(<span class="built_in">id</span>(i,j,<span class="number">1</span>),T,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SAP</span>(S,T)==m) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h3><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>容易发现，方格可以类似国际象棋棋盘进行划分，一半黑一半白，同颜色格子之间互不相邻。任意两个数之间没有公共边，即任意相邻格子都不能同时被选择。</p>
<p>那么我们就可以把黑格和白格分别看成二分图（二部图）的一部。题目所求问题即为“二分图最大点权独立集”（独立集意为选择一些点，使它们互相没有相连的边）。</p>
<p>题目所要求的答案是最大能同时选择的数字和，也就等于所有数字总和减去无法选的数字的和，由最大流最小割定理，如果“最小的无法选的数字和”可以转化为一个最小割模型，那么它就能用最大流算法解决。</p>
<p>设置一个超级源点S和一个超级汇点T，从S向所有黑色格子连容量为该格数字的边，从所有白色格子向T连容量为该格数字的边。从所有黑色格子向相邻的白色格子连容量为无穷大的边（由于容量无穷大，这样的边不会在最小割问题中被割掉）。这样建图后，求解最小割时，只可能割去S到黑色格子的边（表示该格不被选择）以及白色格子到T的边（也表示该格不被选择）。若某处存在从S到T的未用完的流量，则说明互相排斥的两个格子同时被选择，因此去掉最小割后选择的格子必定不互相排斥，且最小割割掉的数字和最小，因此是最优解。</p>
<h4 id="参考代码-16"><a href="#参考代码-16" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn][maxn],S,T;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m,n);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) &#123;<span class="built_in">read</span>(a[i][j]);sum+=a[i][j];&#125;</span><br><span class="line">    graph.<span class="built_in">init</span>(<span class="number">10000</span>);</span><br><span class="line">    S=m*n+<span class="number">1</span>;T=m*n+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>) graph.<span class="built_in">addedge</span>(S,<span class="built_in">c</span>(i,j),a[i][j]);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span> (!((i+j)&amp;<span class="number">1</span>)) graph.<span class="built_in">addedge</span>(<span class="built_in">c</span>(i,j),T,a[i][j]);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>) graph.<span class="built_in">addedge</span>(<span class="built_in">c</span>(i,j),<span class="built_in">c</span>(i<span class="number">-1</span>,j),inf);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">2</span>,n) <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>) graph.<span class="built_in">addedge</span>(<span class="built_in">c</span>(i,j),<span class="built_in">c</span>(i,j<span class="number">-1</span>),inf);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>) graph.<span class="built_in">addedge</span>(<span class="built_in">c</span>(i,j),<span class="built_in">c</span>(i+<span class="number">1</span>,j),inf);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>) graph.<span class="built_in">addedge</span>(<span class="built_in">c</span>(i,j),<span class="built_in">c</span>(i,j+<span class="number">1</span>),inf);</span><br><span class="line">    <span class="keyword">int</span> ans=sum-<span class="built_in">SAP</span>(S,T);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Hard-2"><a href="#Hard-2" class="headerlink" title="Hard"></a>Hard</h2><h3 id="太空飞行计划"><a href="#太空飞行计划" class="headerlink" title="太空飞行计划"></a>太空飞行计划</h3><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>发现这道题仍是“物品选择”问题，考虑最小割的思路。设置一个超级源点S，一个超级汇点T，从S向每个实验连接容量为$p_j$的边，从相联系的实验向仪器各连容量为无穷大的边，从仪器向T连容量为$c_k$的边。最终答案即为$\sum p-最小割$。</p>
<p>S到实验的边若被割掉，代表实验未被选择（因为不选择某个实验会亏钱，相当于会花钱）。仪器到T的边若被割掉，代表仪器被选择（因为选择仪器需要花钱）。若某处存在S到T的未用完的流量，则说明实验被选择且对应的仪器并没有被全部选择，显然并不是符合题意的情况。而最小割的情况下就可以保证所有被选择的实验对应的仪器均被选择。</p>
<h4 id="参考代码-17"><a href="#参考代码-17" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=graph.first[x];k!=<span class="number">-1</span>;k=graph.next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=graph.edge[k].v;</span><br><span class="line">        <span class="keyword">if</span> (!vis[j]&amp;&amp;graph.edge[k].w) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m,n);</span><br><span class="line">    graph.<span class="built_in">init</span>(n+<span class="number">2</span>+m);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">read</span>(w);</span><br><span class="line">        ans+=w;</span><br><span class="line">        graph.<span class="built_in">addedge</span>(n+m+<span class="number">1</span>,i,w);</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> (ss)</span><br><span class="line">        &#123;</span><br><span class="line">            ss&gt;&gt;x;</span><br><span class="line">            graph.<span class="built_in">addedge</span>(i,x+m,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        graph.<span class="built_in">addedge</span>(i+m,n+m+<span class="number">2</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(n+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span> (vis[i]) cout&lt;&lt;(i!=<span class="number">1</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;i;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span> (vis[i+m]) cout&lt;&lt;(i!=<span class="number">1</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;i;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans-<span class="built_in">SAP</span>(n+m+<span class="number">1</span>,n+m+<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>本题实际上是最大权闭合子图模型的一个特殊情况（二分图）</p>
<h5 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>一张有向图中，每个点都有一个权值。定义闭合子图为一个点集和点集内所有点之间的边组成的图，满足若某个点在点集内，则它的后继点也在点集内。当点集的权值和最大时，称作最大权闭合子图。</p>
<h6 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h6><p>该问题事实上可以转化为最小割问题。从S对每一个正权点连一条流量为权值的边，从每个负权点对T连一条流量为权值绝对值的边，将点之间的边的流量设为正无穷，则原图除去最小割即为最大权闭合子图。</p>
<h6 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h6><ol>
<li><p>割边的含义</p>
<p> 由于原图的边都是无穷大，那么割边一定是与S或T相连的。</p>
<p> 割掉S与x的边，表示不选择x点作为子图的点<br> 割掉x与T的边，表示选择x点为子图的点</p>
<p> 如果S与x有边，表示x存在子图中<br> 如果x与T有边，表示x不存在于子图中</p>
</li>
<li><p>只有S与T不连通，图才是闭合子图</p>
<p> 若S与T联通，则必然存在一组点x,y,使得S-&gt;x-&gt;y-&gt;T。则据1的定义，x存在于子图中，y不存在于子图中，则与闭合子图定义矛盾</p>
</li>
<li><p>只要S与T不连通，图即为闭合子图（求最小割的过程中）</p>
<p> 首先剩余的图必定为原图的子图。若某个正权点被选择了，则它指向的所有负权点必然没有被选择。对于正权点指向的别的正权点，最小割过程中将不会割去它(割去的操作只会减小流量而不会断流因此没有收益)</p>
</li>
<li><p>最小割为最优方案</p>
<p> 最小割=(不选的正权和+要选的负权绝对值和）<br> 最大权闭合子图=（正权和-不选的正权和-要选的负权绝对值和）=正权和-最小割<br> 因为正权和是定值，而最小割保证值最小，所以最大权闭合子图一定最优。</p>
</li>
</ol>
<p>参考:<a target="_blank" rel="noopener" href="https://my.oschina.net/u/4417528/blog/3943851">https://my.oschina.net/u/4417528/blog/3943851</a></p>
<h3 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h3><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>将题给的每个点拆成两个点，形成一张二分图。设$x$点拆成$x_1$与$x_2$两个点。则若原图中存在$x$到$y$的有向边，则添加一条$x1$指向$y2$的边。原图的点数减去新图的二分图最大匹配（做法参考<code>搭配飞行员</code>）即为答案。</p>
<p>首先，若不存在任何边，显然答案为原图点数。否则，把拆成的两个点$x_1$当作出点，$x_2$当作入点。每当新图中有一个匹配，即意味着匹配中的某个$x_1$可以连到$y_2$，则原本的$pre\rightarrow x$以及$y\rightarrow nxt$($pre$和$nxt$表示已存在的在$x$结束/从$y$开始的路径，且可以为空)两条路径显然可以变为$pre\rightarrow x\rightarrow y\rightarrow nxt$一条路径，减少了一条，答案减一。要求最小路径覆盖，即要求此处的匹配数最大，因此可以利用二分图匹配解决。</p>
<h4 id="参考代码-18"><a href="#参考代码-18" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,nxt[MAXV];<span class="keyword">bool</span> visited[MAXV];vector&lt;pairs&gt; v;<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last)</span></span>&#123;	visited[x]=<span class="literal">true</span>;	<span class="keyword">for</span> (<span class="keyword">int</span> k=graph.first[x];k!=<span class="number">-1</span>;k=graph.next[k])	&#123;		<span class="keyword">int</span> j=graph.edge[k].v;		<span class="keyword">if</span> (visited[j]) <span class="keyword">continue</span>;		<span class="keyword">if</span> (j==<span class="number">2</span>*n+<span class="number">2</span>) 		&#123;			v.<span class="built_in">push_back</span>(<span class="built_in">mp</span>(last,x-n));			<span class="keyword">return</span>;		&#125;		<span class="built_in">dfs</span>(j,x);	&#125;&#125;<span class="keyword">bool</span> done[MAXV];<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="built_in">read</span>(n,m);	graph.<span class="built_in">init</span>(<span class="number">2</span>*n+<span class="number">2</span>);	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) graph.<span class="built_in">addedge</span>(<span class="number">2</span>*n+<span class="number">1</span>,i,<span class="number">1</span>);	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) graph.<span class="built_in">addedge</span>(i+n,<span class="number">2</span>*n+<span class="number">2</span>,<span class="number">1</span>);	<span class="built_in">rep</span>(i,<span class="number">1</span>,m)	&#123;		<span class="keyword">int</span> u,v;		<span class="built_in">read</span>(u,v);		graph.<span class="built_in">addedge</span>(u,v+n,<span class="number">1</span>);	&#125;	<span class="keyword">int</span> ans=n-<span class="built_in">SAP</span>(<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">2</span>*n+<span class="number">2</span>);	<span class="built_in">dfs</span>(<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">-1</span>);	<span class="keyword">for</span> (<span class="keyword">auto</span> to:v)	nxt[to.first]=to.second;	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) 	&#123;		<span class="keyword">if</span> (!done[i]) 		&#123;			<span class="keyword">for</span> (<span class="keyword">int</span> j=i;j;j=nxt[j])			&#123;				done[j]=<span class="literal">true</span>;				cout&lt;&lt;j&lt;&lt;<span class="string">&#x27; &#x27;</span>;			&#125;			cout&lt;&lt;endl;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;	<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Easy-3"><a href="#Easy-3" class="headerlink" title="Easy"></a>Easy</h2><h3 id="小K的农场"><a href="#小K的农场" class="headerlink" title="小K的农场"></a>小K的农场</h3><p>差分约束的模板题，做法请看《算法导论》。下面的代码用了bellman-ford算法，有兴趣的同学可以自行研究一种该算法的优化——SPFA。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">11111</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.<span class="built_in">push_back</span>(&#123;u,v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t:e)</span><br><span class="line">            <span class="keyword">if</span> (dis[t.v]&gt;dis[t.u]+t.w) dis[t.v]=dis[t.u]+t.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t:e)</span><br><span class="line">        <span class="keyword">if</span> (dis[t.v]&gt;dis[t.u]+t.w) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">addedge</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op,a,b,c;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">addedge</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addedge</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>()) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Medium-3"><a href="#Medium-3" class="headerlink" title="Medium"></a>Medium</h2><h3 id="Bitonic-Shortest-Paths"><a href="#Bitonic-Shortest-Paths" class="headerlink" title="Bitonic Shortest Paths"></a>Bitonic Shortest Paths</h3><p>即《算法导论》思考题24-6，双调最短路径</p>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>题目中所说的合法的双调序列并非一定是先单调增长再单调递减（因为还可以循环移位）。更通用的说法应该是最多有两段先单调增长再单调递减的序列（可能是上、下、上下、下上、上下上、下上下、上下上下、下上下上），也就是最多两段下两段上。</p>
<p>We’ll use the Bellman-Ford algorithm, but with a careful choice of the order in which we relax the edges in order to perform a smaller number of $\text{RELAX}$ operations. In any bitonic path there can be at most two distinct increasing sequences of edge weights, and similarly at most two distinct decreasing sequences of edge weights. Thus, by the path-relaxation property, if we relax the edges in order of increasing weight then decreasing weight twice (for a total of four times relaxing every edge) the we are guaranteed that $v.d$ will equal $\delta(s, v)$ for all $v \in V$ . Sorting the edges takes $O(E\lg E)$. We relax every edge $4$ times, taking $O(E)$. Thus the total runtime is $O(E\lg E) + O(E) = O(E\lg E)$, which is asymptotically faster than the usual $O(VE)$ runtime of Bellman-Ford.</p>
<h4 id="参考代码-19"><a href="#参考代码-19" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000001</span>,maxm=<span class="number">1000001</span>;</span><br><span class="line"><span class="keyword">int</span> s,n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;b)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&gt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxm];</span><br><span class="line"><span class="keyword">double</span> dis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">1e18</span>;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dis[e[i].v]=<span class="built_in">min</span>(dis[e[i].v],dis[e[i].u]+e[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--) dis[e[i].v]=<span class="built_in">min</span>(dis[e[i].v],dis[e[i].u]+e[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dis[e[i].v]=<span class="built_in">min</span>(dis[e[i].v],dis[e[i].u]+e[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--) dis[e[i].v]=<span class="built_in">min</span>(dis[e[i].v],dis[e[i].u]+e[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Hard-3"><a href="#Hard-3" class="headerlink" title="Hard"></a>Hard</h2><h3 id="最短路-1"><a href="#最短路-1" class="headerlink" title="最短路"></a>最短路</h3><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>本题如果直接从单源最短路的经典模型思考，会发现求解过程中很难体现电量不够到不了的这个限制。怎么办？</p>
<p>把可以充电的点看作重要点。由于终点是否是充电点不影响答案，我们可以认为终点是重要点，同时起点一定是重要点，所以如果能将原图重构成一张使答案不变的、包含可达信息的、只包含重要点的图之后，就能用一次单源最短路算法dijkstra求得答案。</p>
<p>我们考虑从某个重要点a出发后不充电能达到的所有重要点，并求出从a出发到各点的最短路。这个问题非常容易解决，以a为源点跑一遍dijkstra，如果有与a距离小于等于k的重要点b，就在重构图中加一条边（从a到b，距离为此处的最短路）。对每个重要点都进行一次这样的操作，复杂度可以优化到$O(n^2\lg n)$。</p>
<p>加上最后一遍对于重构后的图的dijkstra，总复杂度仍然是$O(n^2\lg n)$。</p>
<p>以样例数据为例，标黄的点为重要点</p>
<p><img src="/.io//image-20220207125352138.png" alt="image-20220207125352138"></p>
<p>重构后的图：</p>
<p><img src="/.io//image-20220207130105596.png" alt="image-20220207130105596"></p>
<h4 id="参考代码-20"><a href="#参考代码-20" class="headerlink" title="参考代码"></a>参考代码</h4><p>该代码没有经过各种优化，是最暴力的堆优化dijkstra。但已经完全可以通过本题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1111</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> b[maxn],did[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[maxn],k;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; e[maxn],ee[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line">    b[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);	</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (b[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(did,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(did));</span><br><span class="line">        dis[i]=<span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;,cmp&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()&amp;&amp;did[q.<span class="built_in">top</span>().first]) q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; now=q.<span class="built_in">top</span>();</span><br><span class="line">            did[now.first]=<span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x:e[now.first])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[x.first]&gt;dis[now.first]+x.second) </span><br><span class="line">                &#123;</span><br><span class="line">                    dis[x.first]=dis[now.first]+x.second;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x.first,dis[x.first]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">            <span class="keyword">if</span> (b[i]&amp;&amp;b[j]&amp;&amp;i!=j&amp;&amp;dis[j]&lt;=k) ee[i].<span class="built_in">push_back</span>(&#123;j,dis[j]&#125;);<span class="comment">//虽然是无向图但是这里不用连双向边，因为以j为源点跑dijkstra的时候会连一条与现在反向的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(did,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(did));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;,cmp&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()&amp;&amp;did[q.<span class="built_in">top</span>().first]) q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; now=q.<span class="built_in">top</span>();</span><br><span class="line">        did[now.first]=<span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x:ee[now.first])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[x.first]&gt;dis[now.first]+x.second) </span><br><span class="line">            &#123;</span><br><span class="line">                dis[x.first]=dis[now.first]+x.second;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x.first,dis[x.first]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dis[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/DP/"># DP</a>
                    
                        <a href="/tags/%E5%9B%BE%E8%AE%BA/"># 图论</a>
                    
                        <a href="/tags/%E8%B4%AA%E5%BF%83/"># 贪心</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/10/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A82025%E5%B9%B4%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8linux/">为什么在2025年开始使用GNU/linux</a>
            
        </section>


    </article>
</div>



        </div>
        <footer id="footer" class="footer">
        <div class="copyright">
        <span>© Helloat123 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | 2017 - 2025 </span></span>
    </div>
</footer>

    </div>
</body>
</html>
